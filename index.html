<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Wieloosobowa Strzelanka Samolotowa (Wybór Samolotu)</title>
    <style>
        /* Style bez zmian */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; }
        #score { position: absolute; top: 10px; left: 10px; color: white; font-family: sans-serif; font-size: 24px; background: rgba(0, 0, 0, 0.5); padding: 5px 10px; border-radius: 5px; z-index: 10; }
        #fireButton { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: 60px; height: 60px; border-radius: 50%; background: rgba(255, 0, 0, 0.7); color: white; font-size: 16px; border: none; z-index: 2; display: none; }
        @media (max-width: 768px), (hover: none) and (pointer: coarse) { #fireButton { display: block; } }
        #minimapContainer { position: fixed; bottom: 10px; left: 10px; width: 150px; height: 150px; border: 2px solid white; background-color: rgba(0, 0, 0, 0.5); z-index: 10; }
        #minimapCanvas { width: 100%; height: 100%; display: block; }
        .healthBar { position: absolute; width: 80px; height: 8px; background-color: #555; border: 1px solid #fff; border-radius: 3px; overflow: hidden; z-index: 15; transform: translateX(-50%); pointer-events: none; display: none; }
        .healthBar div { height: 100%; background-color: limegreen; width: 100%; transition: width 0.2s linear; }
        #ranking { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px; border-radius: 10px; border: 2px solid white; font-family: sans-serif; font-size: 18px; z-index: 20; display: none; min-width: 250px; text-align: center; }
        #ranking h2 { margin-top: 0; border-bottom: 1px solid white; padding-bottom: 10px; margin-bottom: 10px; }
        #ranking ul { list-style: none; padding: 0; margin: 0; }
        #ranking li { display: flex; justify-content: space-between; padding: 5px 0; }
        #ranking li span:first-child { text-align: left; flex-grow: 1; margin-right: 15px; }
        #ranking li span:last-child { font-weight: bold; min-width: 30px; text-align: right; }
        #planeSelectionPopup { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center; z-index: 100; }
        #popupContent { background-color: rgba(50, 50, 70, 0.9); padding: 30px; border-radius: 15px; border: 2px solid #aaa; text-align: center; color: white; }
        #popupContent h2 { margin-top: 0; margin-bottom: 20px; font-size: 28px; border-bottom: 1px solid #ccc; padding-bottom: 10px; }
        #planePresentationContainer { width: 80vw; max-width: 900px; height: 40vh; min-height: 300px; margin-bottom: 25px; position: relative; border: 1px solid #555; background-color: rgba(0,0,0,0.2); }
        #planePresentationCanvas { display: block; width: 100%; height: 100%; }
        #planeOptions { display: flex; justify-content: space-around; gap: 20px; }
        .planeOption { cursor: pointer; padding: 15px 20px; border: 1px solid #777; border-radius: 8px; background-color: rgba(80, 80, 100, 0.7); transition: background-color 0.3s, transform 0.2s; flex-basis: 30%; }
        .planeOption:hover { background-color: rgba(100, 100, 140, 0.9); transform: translateY(-3px); }
        .planeOption h3 { margin-top: 0; margin-bottom: 8px; font-size: 18px; }
        .planeOption p { font-size: 14px; color: #ddd; margin-bottom: 0; }
    </style>
</head>

<body>
    <!-- Popup i UI bez zmian -->
    <div id="planeSelectionPopup"> <div id="popupContent"> <h2>Wybierz swój samolot</h2> <div id="planePresentationContainer"> <canvas id="planePresentationCanvas"></canvas> </div> <div id="planeOptions"> <div class="planeOption" data-type="spad"> <h3>SPAD S.XIII</h3> <p>Klasyczny myśliwiec z I WŚ.</p> </div> <div class="planeOption" data-type="redbaron"> <h3>Fokker Dr.I</h3> <p>Legendarny trójpłatowiec.</p> </div> <div class="planeOption" data-type="airplane"> <h3>Generic Jet</h3> <p>Podstawowy odrzutowiec.</p> </div> </div> </div> </div>
    <div id="score">Wybierz samolot...</div>
    <div id="minimapContainer"><canvas id="minimapCanvas"></canvas></div>
    <button id="fireButton">FIRE</button>
    <div id="localPlayerHealthBar" class="healthBar"> <div id="localPlayerHealthFill"></div> </div>
    <div id="ranking"> <h2>Ranking Zestrzeleń</h2> <ul id="rankingList"></ul> </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>
    <script src="planes.js"></script> <!-- Upewnij się, że ten plik jest dostępny -->
    <script>
        // --- Konfiguracja i Stałe (bez zmian) ---
        const WEBSOCKET_URL = "wss://7199-188-146-10-154.ngrok-free.app";
        const STATE_SEND_INTERVAL = 50;
        const INTERPOLATION_FACTOR = 15;
        const MAX_HEALTH = 100;
        const TILE_SIZE = 1000;
        const CARRIER_DISTANCE = 1500;
        const PITCH_SPEED = 1.5;
        const ROLL_SPEED = 2.5;
        const YAW_SPEED = 1.0;
        const FORWARD_SPEED = 80.0;
        const BASE_PROPELLER_SPEED_MULTIPLIER = 90;
        const GROUND_EFFECT_ALTITUDE = 5;
        const CAMERA_DISTANCE = 20;
        const CAMERA_HEIGHT = 5;
        const MIN_GROUND_ALTITUDE = 2; // Minimalna wysokość nad ziemią/wodą

        // --- Zmienne Globalne (bez zmian) ---
        let localPlayerId = null;
        let opponentPlanes = {};
        let showRanking = false;
        const rankingDiv = document.getElementById('ranking');
        const rankingList = document.getElementById('rankingList');
        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
        let scene, camera, renderer;
        let plane;
        let keys = {};
        let bullets = [];
        let buildings = [];
        let carriers = [];
        let score = 0;
        const scoreDiv = document.getElementById('score');
        const tiles = [];
        let touchPitchInput = 0;
        let touchRollInput = 0;
        let touchStartX = null, touchStartY = null;
        let currentPropellerSpeedMultiplier = BASE_PROPELLER_SPEED_MULTIPLIER;
        const localHealthBar = document.getElementById('localPlayerHealthBar');
        const localHealthFill = document.getElementById('localPlayerHealthFill');
        let minimapCanvas, minimapCtx;
        const MINIMAP_SIZE = 150, MAP_SCALE = 0.015;
        const clock = new THREE.Clock();
        let socket = null;
        let isConnected = false;
        let lastSentState = {};
        let gameStarted = false;

        // --- Zmienne dla Popupu Wyboru Samolotu (bez zmian) ---
        let popupScene, popupCamera, popupRenderer;
        let spadPreview, baronPreview, airplanePreview;
        const previewPlanes = [];
        let hoveredPlanePreview = null;
        let popupAnimationId = null;
        const popupRaycaster = new THREE.Raycaster();
        const popupMouse = new THREE.Vector2();
        let selectedPlaneType = 'airplane';
        const planeSelectionPopup = document.getElementById('planeSelectionPopup');
        const planePresentationCanvas = document.getElementById('planePresentationCanvas');
        const planeOptionsDiv = document.getElementById('planeOptions');

        // --- Mapa funkcji tworzących samoloty (bez zmian) ---
        const planeCreators = { spad: createSPAD, redbaron: createRedBaron, airplane: createAirplane };

        // --- Zmienne dla Eksplozji (bez zmian) ---
        let activeExplosions = [];

        // --- Inicjalizacja Popupu (bez zmian) ---
        showPlaneSelectionPopup();
        function showPlaneSelectionPopup(){ planeSelectionPopup.style.display='flex'; initPopupScene(); animatePopup(); }
        function initPopupScene(){ popupScene=new THREE.Scene(); popupScene.background=new THREE.Color(0x333344); const a=planePresentationCanvas.clientWidth/planePresentationCanvas.clientHeight; popupCamera=new THREE.PerspectiveCamera(50,a,0.1,100); popupCamera.position.set(0,2,15); popupCamera.lookAt(0,0,0); popupRenderer=new THREE.WebGLRenderer({canvas:planePresentationCanvas,antialias:true,alpha:true}); popupRenderer.setSize(planePresentationCanvas.clientWidth,planePresentationCanvas.clientHeight); popupRenderer.setPixelRatio(window.devicePixelRatio); popupScene.add(new THREE.AmbientLight(0xffffff,1.0)); const p=new THREE.DirectionalLight(0xffffff,1.5); p.position.set(5,10,7); popupScene.add(p); spadPreview=createSPAD(0xffffff); spadPreview.position.x=-6; spadPreview.userData.type='spad'; popupScene.add(spadPreview); previewPlanes.push(spadPreview); baronPreview=createRedBaron(0xff0000); baronPreview.position.x=0; baronPreview.userData.type='redbaron'; popupScene.add(baronPreview); previewPlanes.push(baronPreview); airplanePreview=createAirplane(0x0055ff); airplanePreview.position.x=6; airplanePreview.userData.type='airplane'; popupScene.add(airplanePreview); previewPlanes.push(airplanePreview); previewPlanes.forEach(p=>p.scale.set(0.8,0.8,0.8)); planePresentationCanvas.addEventListener('mousemove',onPopupMouseMove,false); planePresentationCanvas.addEventListener('mouseleave',onPopupMouseLeave,false); planeOptionsDiv.addEventListener('click',onPlaneOptionClick); }
        function onPopupMouseMove(e){ const r=planePresentationCanvas.getBoundingClientRect(); popupMouse.x=((e.clientX-r.left)/r.width)*2-1; popupMouse.y=-((e.clientY-r.top)/r.height)*2+1; popupRaycaster.setFromCamera(popupMouse,popupCamera); const i=popupRaycaster.intersectObjects(previewPlanes,true); if(i.length>0){ let t=i[0].object; while(t.parent&&!previewPlanes.includes(t)){t=t.parent;} hoveredPlanePreview=previewPlanes.includes(t)?t:null; }else{hoveredPlanePreview=null;} }
        function onPopupMouseLeave(e){ hoveredPlanePreview=null; }
        function onPlaneOptionClick(e){ const o=e.target.closest('.planeOption'); if(o&&o.dataset.type){ selectedPlaneType=o.dataset.type; console.log(`Wybrano: ${selectedPlaneType}`); planeSelectionPopup.style.display='none'; if(popupAnimationId){cancelAnimationFrame(popupAnimationId);popupAnimationId=null;} startGame();}}
        function animatePopup(){ popupAnimationId=requestAnimationFrame(animatePopup); const r=0.02; previewPlanes.forEach(p=>{if(p===hoveredPlanePreview){p.rotation.y+=r; p.position.y=Math.sin(Date.now()*0.002)*0.1;}else{p.position.y*=0.95;}}); popupRenderer.render(popupScene,popupCamera); }

        // --- Start Gry (bez zmian) ---
        function startGame(){ if(gameStarted)return; gameStarted=true; scoreDiv.innerText="Łączenie..."; initMainGame(); connectWebSocket(); animate(); }

        // --- Inicjalizacja Głównej Gry (bez zmian) ---
        function initMainGame(){ if(hasTouch)document.getElementById('fireButton').style.display='block'; else document.getElementById('fireButton').style.display='none'; minimapCanvas=document.getElementById('minimapCanvas'); minimapCtx=minimapCanvas.getContext('2d'); minimapCanvas.width=MINIMAP_SIZE; minimapCanvas.height=MINIMAP_SIZE; scene=new THREE.Scene(); scene.background=new THREE.Color(0x87ceeb); camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,10000); renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth,window.innerHeight); document.body.appendChild(renderer.domElement); scene.add(new THREE.AmbientLight(0xffffff,0.7)); const d=new THREE.DirectionalLight(0xffffff,0.8); d.position.set(100,200,-50); scene.add(d); createTiles(); createBuildings(); createCarriers(); const cF=planeCreators[selectedPlaneType]||planeCreators.airplane; plane=cF(0xffffff); plane.visible=false; plane.rotation.order='YXZ'; scene.add(plane); localHealthBar.style.display='none'; window.addEventListener('resize',onWindowResize); window.addEventListener('keydown',onKeyDown); window.addEventListener('keyup',onKeyUp); window.addEventListener('touchstart',onTouchStart,{passive:false}); window.addEventListener('touchmove',onTouchMove,{passive:false}); window.addEventListener('touchend',onTouchEnd); const fb=document.getElementById('fireButton'); fb.addEventListener('touchstart',e=>{e.preventDefault();if(plane&&plane.userData.isAlive)fireGuns();});}

        // --- WebSocket (bez zmian) ---
        function connectWebSocket(){ console.log("Conn WS..."); socket=new WebSocket(WEBSOCKET_URL); socket.onopen=()=>{console.log("WS Conn!"); isConnected=true; scoreDiv.innerText="Połączono!"; if(localPlayerId){sendWebSocketMessage({type:'select_plane',planeType:selectedPlaneType});} setInterval(sendStateUpdateIfNeeded,STATE_SEND_INTERVAL);}; socket.onmessage=(e)=>{try{handleServerMessage(JSON.parse(e.data));}catch(err){console.error("Parse Err:",err,e.data);}}; socket.onclose=(e)=>{console.log("WS Disc.",e.reason); isConnected=false; gameStarted=false; localPlayerId=null; scoreDiv.innerText="Rozłączono. Odśwież."; Object.keys(opponentPlanes).forEach(removeOpponent); if(plane)plane.visible=false; localHealthBar.style.display='none'; keys={}; activeExplosions.forEach(exp => scene.remove(exp)); activeExplosions = [];}; socket.onerror=(e)=>{console.error("WS Err:",e); scoreDiv.innerText="Błąd. Odśwież."; gameStarted=false;};}
        function sendWebSocketMessage(d){ if(isConnected&&socket&&socket.readyState===WebSocket.OPEN){socket.send(JSON.stringify(d));}else{console.warn("Cannot send: WS closed.");}}
        function handleServerMessage(m){ switch(m.type){ case 'your_id': localPlayerId=m.id; console.log("My ID:",localPlayerId); sendWebSocketMessage({type:'select_plane',planeType:selectedPlaneType}); setupLocalPlane(); break; case 'game_state': console.log("Init game state"); const cP=Object.keys(m.state||{}); Object.keys(opponentPlanes).forEach(oId=>{if(oId!=localPlayerId&&!cP.includes(String(oId))){removeOpponent(oId);}}); for(const pId in m.state){ const pD=m.state[pId]; if(pId==localPlayerId){updateLocalPlayerFromServer(pD);}else{handleOpponentUpdate(pId,pD);}} break; case 'player_joined': console.log("Joined:",m.player.id,"Type:",m.player.planeType); if(m.player.id!=localPlayerId){handleOpponentUpdate(m.player.id,m.player);} break; case 'player_update': const pD=m.player; if(pD.id==localPlayerId){updateLocalPlayerFromServer(pD);}else{handleOpponentUpdate(pD.id,pD);} break; case 'player_left': console.log("Left:",m.id); removeOpponent(m.id); break; case 'player_killed': console.log(`Kill: ${m.killerId} -> ${m.victimId}`); break; default: console.warn("Unk msg type:",m.type); } if(showRanking){updateRankingWebSocket();}}
        function setupLocalPlane(){ if(!plane||localPlayerId===null)return; plane.userData.id=localPlayerId; plane.userData.maxHealth=MAX_HEALTH; plane.userData.collisionRadius=5; plane.userData.planeType=selectedPlaneType; console.log(`Local plane (${localPlayerId}) init as: ${selectedPlaneType}`);}
        function updateLocalPlayerFromServer(sD){ if(!plane||localPlayerId===null)return; const wA=plane.userData.isAlive; const iNA=sD.isAlive; plane.userData.health=sD.health; plane.userData.kills=sD.kills; plane.userData.isAlive=iNA; if((iNA&&!wA)||!plane.visible){ console.log("Set local pos/rot from server:",sD.x,sD.y,sD.z,sD.rotY,sD.rotX,sD.rotZ); if(sD.x!==undefined)plane.position.x=sD.x; if(sD.y!==undefined)plane.position.y=sD.y; if(sD.z!==undefined)plane.position.z=sD.z; const iR=new THREE.Euler(sD.rotX||0,sD.rotY||0,sD.rotZ||0,'YXZ'); plane.setRotationFromEuler(iR); plane.quaternion.setFromEuler(iR); } if(iNA){ plane.visible=true; localHealthBar.style.display='block'; if(!wA){ console.log("Local respawned by server."); keys={}; touchPitchInput=0; touchRollInput=0; } updateHealthBar(plane,localHealthFill); positionHealthBar(plane,localHealthBar); }else if(wA){ console.log("Local killed by server."); handlePlayerDeath(plane); }}
        function sendStateUpdateIfNeeded(){ if(!isConnected||!plane||!plane.userData.isAlive||!plane.visible||localPlayerId===null)return; const cS={x:parseFloat(plane.position.x.toFixed(2)),y:parseFloat(plane.position.y.toFixed(2)),z:parseFloat(plane.position.z.toFixed(2)),rotX:parseFloat(plane.rotation.x.toFixed(3)),rotY:parseFloat(plane.rotation.y.toFixed(3)),rotZ:parseFloat(plane.rotation.z.toFixed(3))}; if(JSON.stringify(cS)!==JSON.stringify(lastSentState)){sendWebSocketMessage({type:'update_state',state:cS});lastSentState=cS;}}

        // --- Pętla Główna Gry --- ZMIENIONE STEROWANIE PITCH
        function animate(time) {
             if (!gameStarted) return;
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1);

            // --- Sterowanie Lokalnym Graczem ---
            if (plane && plane.userData.isAlive && plane.visible) {
                let pitchDelta=0, rollDelta=0, yawDelta=0;

                // Pitch (Góra/Dół) - ZMIENIONE ZNAKI
                if(keys['arrowup']||keys['w']) pitchDelta += PITCH_SPEED * deltaTime; // Pitch Down (Nurkowanie)
                if(keys['arrowdown']||keys['s']) pitchDelta -= PITCH_SPEED * deltaTime; // Pitch Up (Wznoszenie)

                // Roll (Lewo/Prawo) - bez zmian od poprzedniej modyfikacji
                if(keys['arrowleft']||keys['a']) rollDelta -= ROLL_SPEED * deltaTime; // Roll Left
                if(keys['arrowright']||keys['d']) rollDelta += ROLL_SPEED * deltaTime; // Roll Right

                // Yaw (Ster kierunku) - bez zmian
                if(keys['q'])yawDelta+=YAW_SPEED*deltaTime;
                if(keys['e'])yawDelta-=YAW_SPEED*deltaTime;

                // Sterowanie Dotykowe - ZMIENIONY ZNAK PRZY PITCH
                if(hasTouch){
                    if(touchPitchInput!==0){ pitchDelta += touchPitchInput * PITCH_SPEED * deltaTime; } // Zmieniono += na -=
                    if(touchRollInput!==0){ rollDelta += touchRollInput * ROLL_SPEED * deltaTime * 1.5; }
                }

                // Zastosowanie Rotacji - bez zmian
                if(Math.abs(pitchDelta)>0.001)plane.rotateX(pitchDelta);
                if(Math.abs(rollDelta)>0.001)plane.rotateZ(rollDelta);
                if(Math.abs(yawDelta)>0.001)plane.rotateY(yawDelta);

                // Ruch do przodu i kolizje - bez zmian
                const forwardDir=new THREE.Vector3(0,0,1).applyQuaternion(plane.quaternion);
                let currentForwardSpeed=FORWARD_SPEED;
                if(plane.position.y<GROUND_EFFECT_ALTITUDE){const f=Math.max(0,plane.position.y/GROUND_EFFECT_ALTITUDE);currentForwardSpeed*=f; currentPropellerSpeedMultiplier=BASE_PROPELLER_SPEED_MULTIPLIER*f;}else{currentPropellerSpeedMultiplier+=(BASE_PROPELLER_SPEED_MULTIPLIER-currentPropellerSpeedMultiplier)*5*deltaTime;}
                const forwardMove=currentForwardSpeed*deltaTime;
                plane.position.add(forwardDir.multiplyScalar(forwardMove));

                if (plane.position.y < MIN_GROUND_ALTITUDE && plane.userData.isAlive) {
                    console.log("Collision with ground/water!");
                    createExplosion(plane.position.clone().setY(MIN_GROUND_ALTITUDE));
                    takeDamage(plane, MAX_HEALTH * 2, 'Ground');
                }

                if (plane.userData.propeller) { plane.userData.propeller.rotation.z += currentPropellerSpeedMultiplier * deltaTime; }

                checkCollisions(plane);
                checkPlayerCollisions(plane);

                positionHealthBar(plane, localHealthBar);
            }

            // --- Aktualizacje Niezależne od Stanu Gracza ---
            updateTiles();
            updateBullets(deltaTime);
            updateOpponentPlanes(deltaTime);
            updateExplosions(deltaTime);
            updateCamera();
            renderer.render(scene, camera);
            updateMinimap();
            updateScoreboard();
        }

        // --- Funkcje Tworzące Elementy Sceny (bez zmian) ---
        function createTiles(){ const wc=0x003366, lc=0x228B22; for(let x=-2; x<=2; x++) for(let z=-2; z<=2; z++){ const c=(x===0&&z===0)?lc:wc; const m=new THREE.MeshStandardMaterial({color:c, roughness:(x===0&&z===0)?0.8:0.6, metalness:0.1}); const t=new THREE.Mesh(new THREE.PlaneGeometry(TILE_SIZE,TILE_SIZE),m); t.rotation.x=-Math.PI/2; t.userData.gridX=x; t.userData.gridZ=z; scene.add(t); tiles.push(t);}}
        function createBuildings(){ const m=new THREE.MeshStandardMaterial({color:0x555555,roughness:0.7,metalness:0.3}); for(let i=0; i<150; i++){ const w=Math.random()*15+10, d=Math.random()*15+10, h=Math.random()*120+50; const g=new THREE.BoxGeometry(w,h,d), b=new THREE.Mesh(g,m); b.position.set((Math.random()-0.5)*(TILE_SIZE*0.9),h/2,(Math.random()-0.5)*(TILE_SIZE*0.9)); b.userData.radius=Math.max(w,d)/2*1.1; b.userData.health=3; buildings.push(b); scene.add(b);}}
        function createCarriers(){ const g=new THREE.BoxGeometry(80,20,500), m=new THREE.MeshStandardMaterial({color:0x444455, roughness:0.8}); const p=[{x:0,z:-CARRIER_DISTANCE,r:0},{x:CARRIER_DISTANCE,z:0,r:Math.PI/2},{x:0,z:CARRIER_DISTANCE,r:0},{x:-CARRIER_DISTANCE,z:0,r:Math.PI/2}]; p.forEach(pos=>{ const c=new THREE.Mesh(g,m); c.position.set(pos.x,10,pos.z); c.rotation.y=pos.r; c.userData.radius=250; c.userData.isCarrier=true; c.userData.health=Infinity; carriers.push(c); scene.add(c);});}

        // --- Funkcje Eksplozji (bez zmian) ---
        function createExplosion(position){ console.log("Creating explosion at:",position); const eg=new THREE.Group(); eg.position.copy(position); const pC=50; const pS=0.5; const eS=40; const mL=1.5; const pG=new THREE.SphereGeometry(pS,4,4); for(let i=0; i<pC; i++){ const c=new THREE.Color().lerpColors(new THREE.Color(0xffff00),new THREE.Color(0xff0000),Math.random()); const pM=new THREE.MeshBasicMaterial({color:c,transparent:true,opacity:1.0}); const p=new THREE.Mesh(pG,pM); p.position.set((Math.random()-0.5)*pS*2,(Math.random()-0.5)*pS*2,(Math.random()-0.5)*pS*2); p.userData.velocity=new THREE.Vector3((Math.random()-0.5),(Math.random()-0.5),(Math.random()-0.5)).normalize().multiplyScalar(eS*(0.5+Math.random()*0.5)); p.userData.life=0; p.userData.maxLife=mL*(0.7+Math.random()*0.3); eg.add(p);} eg.userData.life=0; eg.userData.maxLife=mL; scene.add(eg); activeExplosions.push(eg);}
        function updateExplosions(dT){ for(let i=activeExplosions.length-1; i>=0; i--){ const e=activeExplosions[i]; e.userData.life+=dT; if(e.userData.life>=e.userData.maxLife){scene.remove(e); activeExplosions.splice(i,1); continue;} for(let j=e.children.length-1; j>=0; j--){ const p=e.children[j]; p.userData.life+=dT; if(p.userData.life>=p.userData.maxLife){e.remove(p); continue;} p.position.add(p.userData.velocity.clone().multiplyScalar(dT)); p.userData.velocity.y-=9.8*dT*2; const lR=p.userData.life/p.userData.maxLife; p.material.opacity=1.0-lR; p.material.color.lerp(new THREE.Color(0x555555),dT*2); p.scale.multiplyScalar(1-dT*0.5);}}}

        // --- Funkcje Aktualizujące (bez zmian) ---
        function updateOpponentPlanes(dT){ for(const id in opponentPlanes){const oD=opponentPlanes[id]; const o=oD.plane; const hB=oD.healthBar; if(!o||!o.parent)continue; if(o.userData.isAlive){ if(oD.targetPos){o.position.lerp(oD.targetPos,INTERPOLATION_FACTOR*dT);} if(oD.targetQuat){o.quaternion.slerp(oD.targetQuat,INTERPOLATION_FACTOR*dT);} if(o.userData.propeller){o.userData.propeller.rotation.z+=BASE_PROPELLER_SPEED_MULTIPLIER*0.15*dT;} if(hB){updateHealthBar(o,hB.firstChild); positionHealthBar(o,hB);}}}}
        function updateTiles(){ if(!plane||!plane.parent||!gameStarted)return; const px=Math.round(plane.position.x/TILE_SIZE), pz=Math.round(plane.position.z/TILE_SIZE); tiles.forEach(t=>{const wx=(px+t.userData.gridX)*TILE_SIZE; const wz=(pz+t.userData.gridZ)*TILE_SIZE; t.position.set(wx,0,wz);});}
        function updateBullets(dT){ if(!gameStarted)return; const rangeSq=6000*6000; for(let i=bullets.length-1; i>=0; i--){ const b=bullets[i]; if(!b||!b.parent){bullets.splice(i,1); continue;} b.userData.life=(b.userData.life||0)+dT; if(b.userData.life>4.0){scene.remove(b); bullets.splice(i,1); continue;} b.position.add(b.userData.velocity.clone().multiplyScalar(dT)); let hit=false; for(const bd of buildings){ if(!bd.parent)continue; if(b.position.distanceToSquared(bd.position)<(bd.userData.radius+0.5)**2){ bd.userData.health--; if(bd.userData.health<=0){ removeBuilding(bd); if(b.userData.ownerId===localPlayerId)score+=25;} scene.remove(b); bullets.splice(i,1); hit=true; break;}} if(hit)continue; for(const cr of carriers){ if(!cr.parent)continue; if(b.position.distanceToSquared(cr.position)<(cr.userData.radius+0.5)**2 && Math.abs(b.position.y-cr.position.y)<15){ scene.remove(b); bullets.splice(i,1); hit=true; break;}} if(hit)continue; if(b.userData.ownerId===localPlayerId){for(const oId in opponentPlanes){ const oData=opponentPlanes[oId]; if(!oData||!oData.plane||!oData.plane.userData.isAlive)continue; if(b.position.distanceToSquared(oData.plane.position)<(oData.plane.userData.collisionRadius+0.5)**2){ console.log(`LP hit opp ${oId}!`); sendWebSocketMessage({type:'hit_player',targetId:parseInt(oId),damage:b.userData.damage}); scene.remove(b); bullets.splice(i,1); hit=true; break;}}} if(hit)continue; if(b.position.lengthSq()>rangeSq){scene.remove(b); bullets.splice(i,1);}}}
        function updateCamera(){ if(!plane||!plane.parent||!gameStarted)return; const o=new THREE.Vector3(0,CAMERA_HEIGHT,-CAMERA_DISTANCE); const cTP=o.applyMatrix4(plane.matrixWorld); camera.position.lerp(cTP,0.1); const lAT=new THREE.Vector3(0,0,10).applyMatrix4(plane.matrixWorld); camera.lookAt(lAT);}
        function updateMinimap(){ if(!minimapCtx||!plane||!plane.parent||!gameStarted) return; minimapCtx.fillStyle='rgba(0,0,0,0.5)'; minimapCtx.fillRect(0,0,MINIMAP_SIZE,MINIMAP_SIZE); minimapCtx.save(); minimapCtx.translate(MINIMAP_SIZE/2,MINIMAP_SIZE/2); minimapCtx.scale(MAP_SCALE,MAP_SCALE); minimapCtx.rotate(-plane.rotation.y); minimapCtx.translate(-plane.position.x,-plane.position.z); tiles.forEach(t=>{const c=t.userData.gridX===0&&t.userData.gridZ===0?'rgb(34,136,34)':'rgb(0,51,102)'; minimapCtx.fillStyle=c; minimapCtx.fillRect(t.position.x-TILE_SIZE/2, t.position.z-TILE_SIZE/2, TILE_SIZE, TILE_SIZE);}); minimapCtx.fillStyle='grey'; buildings.forEach(b=>{if(!b.parent)return; const w=b.geometry.parameters.width*1.5, d=b.geometry.parameters.depth*1.5; minimapCtx.fillRect(b.position.x-w/2,b.position.z-d/2,w,d);}); minimapCtx.fillStyle='darkgrey'; carriers.forEach(c=>{if(!c.parent)return; minimapCtx.save(); minimapCtx.translate(c.position.x,c.position.z); minimapCtx.rotate(c.rotation.y); const w=c.geometry.parameters.width, d=c.geometry.parameters.depth; minimapCtx.fillRect(-w/2,-d/2,w,d); minimapCtx.restore();}); minimapCtx.fillStyle='blue'; for (const id in opponentPlanes){const o=opponentPlanes[id]; if(o&&o.plane&&o.plane.userData.isAlive){minimapCtx.beginPath(); minimapCtx.arc(o.plane.position.x,o.plane.position.z,150,0,Math.PI*2); minimapCtx.fill();}} minimapCtx.restore(); minimapCtx.save(); minimapCtx.translate(MINIMAP_SIZE/2,MINIMAP_SIZE/2); minimapCtx.fillStyle='red'; minimapCtx.beginPath(); minimapCtx.moveTo(0,-6); minimapCtx.lineTo(-4,6); minimapCtx.lineTo(4,6); minimapCtx.closePath(); minimapCtx.fill(); minimapCtx.restore(); }
        function updateScoreboard(){ if (!plane||localPlayerId===null||plane.userData.kills===undefined||!gameStarted) return; scoreDiv.innerText=`Kills: ${plane.userData.kills} / Score: ${score}`; }
        function updateRankingWebSocket(){ rankingList.innerHTML=''; const pD=[]; if(plane&&localPlayerId!==null&&plane.userData.kills!==undefined&&gameStarted){pD.push({id:localPlayerId,kills:plane.userData.kills,name:`Ty (${plane.userData.planeType||'?'})`});} for(const pI in opponentPlanes){const oD=opponentPlanes[pI]; if(oD&&oD.plane&&oD.plane.userData.kills!==undefined){const n=`Gracz ${String(pI).substr(-4)} (${oD.planeType||'?'})`; pD.push({id:pI,kills:oD.plane.userData.kills,name:n});}} pD.sort((a,b)=>b.kills-a.kills); pD.forEach(p=>{const li=document.createElement('li'),nS=document.createElement('span'),kS=document.createElement('span'); nS.textContent=p.name; kS.textContent=p.kills; if(p.id==localPlayerId)li.style.color='yellow'; li.appendChild(nS); li.appendChild(kS); rankingList.appendChild(li);});}

        // --- Akcje Gracza i Kolizje (bez zmian w logice poza animate) ---
        function fireGuns(){ if(!plane||!plane.userData.isAlive||!plane.visible||!gameStarted)return; const gP=plane.userData.gunPositions; if(!gP||gP.length===0)return; gP.forEach(lp=>{const wg=lp.clone().applyMatrix4(plane.matrixWorld); const fd=new THREE.Vector3(0,0,1).applyQuaternion(plane.quaternion).normalize(); const bg=new THREE.SphereGeometry(0.25,8,8); const bm=new THREE.MeshBasicMaterial({color:0xffff00}); const b=new THREE.Mesh(bg,bm); b.position.copy(wg); const bS=700; b.userData.velocity=fd.clone().multiplyScalar(bS); b.userData.ownerId=localPlayerId; b.userData.damage=15; scene.add(b); bullets.push(b);});}
        function checkCollisions(targetPlane){ if(!targetPlane||!targetPlane.userData.isAlive||!targetPlane.visible||!gameStarted)return; const pRad=targetPlane.userData.collisionRadius; const obstacles=[...buildings,...carriers]; for(const o of obstacles){ if(!o.parent)continue; const oRad=o.userData.radius; const dSq=targetPlane.position.distanceToSquared(o.position); const minDSq=(pRad+oRad)**2; const hDiff=Math.abs(targetPlane.position.y-o.position.y); const vThresh=o.userData.isCarrier?20:(o.geometry.parameters.height/2+pRad); if(dSq<minDSq&&hDiff<vThresh){ console.log(`Collision: ${targetPlane.userData.id} with ${o.userData.isCarrier?'carrier':'building'}`); const dist=Math.sqrt(dSq); const overlap=(pRad+oRad)-dist; const pushDir=targetPlane.position.clone().sub(o.position).normalize(); targetPlane.position.add(pushDir.multiplyScalar(overlap*1.05)); if(targetPlane===plane&&targetPlane.userData.id===localPlayerId){ const damage=o.userData.isCarrier?MAX_HEALTH:MAX_HEALTH*2; createExplosion(targetPlane.position.clone()); takeDamage(plane,damage,o.userData.isCarrier?'Carrier':'Building');}}}}
        function checkPlayerCollisions(localPlane){ if(!localPlane||!localPlane.userData.isAlive||!localPlane.visible)return; const localRadius=localPlane.userData.collisionRadius; for(const opponentId in opponentPlanes){ const oppData=opponentPlanes[opponentId]; if(!oppData||!oppData.plane||!oppData.plane.userData.isAlive||!oppData.plane.visible)continue; const opponentPlane=oppData.plane; const opponentRadius=opponentPlane.userData.collisionRadius; const combinedRadius=localRadius+opponentRadius; const distanceSq=localPlane.position.distanceToSquared(opponentPlane.position); if(distanceSq<combinedRadius*combinedRadius){ console.log(`Collision between local player ${localPlayerId} and opponent ${opponentId}!`); const collisionPoint=localPlane.position.clone().lerp(opponentPlane.position,0.5); createExplosion(collisionPoint); takeDamage(localPlane,MAX_HEALTH*2,`Collision with ${opponentId}`); sendWebSocketMessage({type:'hit_player',targetId:parseInt(opponentId),damage:MAX_HEALTH*2,killerId:localPlayerId}); break;}}}
        function removeBuilding(b){ scene.remove(b); const i=buildings.indexOf(b); if(i>-1) buildings.splice(i,1); }
        function takeDamage(targetPlane, amount, killerIdOrReason){ if (!targetPlane||!targetPlane.userData.isAlive||!targetPlane.visible)return; const previousHealth=targetPlane.userData.health; targetPlane.userData.health=Math.max(0,targetPlane.userData.health-amount); console.log(`Player ${targetPlane.userData.id} took ${amount} dmg from ${killerIdOrReason||'Unknown'}. HP: ${targetPlane.userData.health}`); if(targetPlane.userData.health<=0&&previousHealth>0){ console.log(`Player ${targetPlane.userData.id} died.`); if(targetPlane===plane&&targetPlane.userData.id===localPlayerId){ handlePlayerDeath(targetPlane); let killerPlayerId=null; if(typeof killerIdOrReason==='number'||(typeof killerIdOrReason==='string'&&!isNaN(parseInt(killerIdOrReason)))){killerPlayerId=parseInt(killerIdOrReason);}else if(typeof killerIdOrReason==='string'&&killerIdOrReason.startsWith('Collision with ')){killerPlayerId=parseInt(killerIdOrReason.split(' ')[2]);} sendWebSocketMessage({type:'i_died',killerId:killerPlayerId});}else{handleOpponentDeathVisuals(targetPlane);}} if(targetPlane===plane){updateHealthBar(plane,localHealthFill);}}
        function handlePlayerDeath(deadPlane){ if(!deadPlane.userData.isAlive && !deadPlane.visible) return; console.log(`Handling local death effects for ${deadPlane.userData.id}`); deadPlane.userData.isAlive=false; deadPlane.visible=false; localHealthBar.style.display='none'; keys={}; touchPitchInput=0; touchRollInput=0;}
        function handleOpponentDeathVisuals(deadOpponentPlane){ console.log(`Death visuals for opponent ${deadOpponentPlane.userData.id}`); deadOpponentPlane.visible=false; const oD=opponentPlanes[deadOpponentPlane.userData.id]; if(oD&&oD.healthBar){oD.healthBar.style.display='none';}}

        // --- Obsługa Sieciowa (Przeciwnicy) (bez zmian) ---
        function handleOpponentUpdate(pId,pD){ let oD=opponentPlanes[pId]; const iJ=!oD; const rPT=pD.planeType||'airplane'; if(iJ){console.log(`Adding opp: ${pId}, Type: ${rPT}`); const cF=planeCreators[rPT]||planeCreators.airplane; const oP=cF(0x0055ff); oP.rotation.order='YXZ'; oP.userData.id=parseInt(pId); oP.userData.collisionRadius=5; oP.userData.maxHealth=MAX_HEALTH; oP.userData.planeType=rPT; const hBE=createHealthBarElement(); document.body.appendChild(hBE); oD={plane:oP,healthBar:hBE,targetPos:new THREE.Vector3(),targetQuat:new THREE.Quaternion(),planeType:rPT}; opponentPlanes[pId]=oD; oD.targetPos.set(pD.x,pD.y,pD.z); const iR=new THREE.Euler(pD.rotX||0,pD.rotY||0,pD.rotZ||0,'YXZ'); oD.targetQuat.setFromEuler(iR); oP.position.copy(oD.targetPos); oP.quaternion.copy(oD.targetQuat); scene.add(oP);}else{if(oD.planeType!==rPT){console.log(`Opp ${pId} changed type ${oD.planeType} -> ${rPT}. Replace.`); scene.remove(oD.plane); const cF=planeCreators[rPT]||planeCreators.airplane; const nOP=cF(0x0055ff); nOP.rotation.order='YXZ'; nOP.userData.id=parseInt(pId); nOP.userData.collisionRadius=5; nOP.userData.maxHealth=MAX_HEALTH; nOP.userData.planeType=rPT; oD.plane=nOP; oD.planeType=rPT; nOP.position.copy(oD.targetPos); nOP.quaternion.copy(oD.targetQuat); scene.add(nOP);}} const o=oD.plane; const hB=oD.healthBar; const wA=o.userData.isAlive; const iNA=pD.isAlive; oD.targetPos.set(pD.x,pD.y,pD.z); const tR=new THREE.Euler(pD.rotX||0,pD.rotY||0,pD.rotZ||0,'YXZ'); oD.targetQuat.setFromEuler(tR); o.userData.health=pD.health; o.userData.kills=pD.kills; o.userData.isAlive=iNA; if(iNA){o.visible=true; if(hB){hB.style.display='block';} if(!wA){console.log(`Opp ${pId} respawn/join.`); o.position.copy(oD.targetPos); o.quaternion.copy(oD.targetQuat);}}else{o.visible=false; if(hB){hB.style.display='none';} if(wA){console.log(`Opp ${pId} died.`);}}}
        function removeOpponent(pId){ console.log("Removing opp:",pId); const o=opponentPlanes[pId]; if(o){if(o.plane)scene.remove(o.plane); if(o.healthBar&&o.healthBar.parentNode){o.healthBar.parentNode.removeChild(o.healthBar);} delete opponentPlanes[pId];}}

        // --- UI i Elementy Pomocnicze (bez zmian) ---
        function createHealthBarElement(){ const b=document.createElement('div'); b.className='healthBar'; const f=document.createElement('div'); b.appendChild(f); b.style.display='none'; return b;}
        function updateHealthBar(t,f){ if(!t||!f||t.userData.health===undefined||t.userData.maxHealth===undefined)return; const p=(t.userData.health/t.userData.maxHealth)*100; f.style.width=`${Math.max(0,p)}%`; if(p>60)f.style.backgroundColor='limegreen'; else if(p>30)f.style.backgroundColor='gold'; else f.style.backgroundColor='red';}
        function positionHealthBar(t,b){ if (!t||!t.parent||!t.visible||!b||!camera){if(b)b.style.display='none'; return;} const v=new THREE.Vector3(); v.copy(t.position).y+=4; v.project(camera); if(v.z>1||v.z<-1){b.style.display='none'; return;} const x=(v.x*0.5+0.5)*renderer.domElement.clientWidth, y=(-v.y*0.5+0.5)*renderer.domElement.clientHeight; b.style.left=`${x}px`; b.style.top=`${y-10}px`; b.style.display='block';}

        // --- Event Listeners --- ZMIENIONE STEROWANIE DOTYKOWE PITCH
        function onWindowResize(){ if(camera&&renderer){camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight);} if(popupCamera&&popupRenderer&&planePresentationCanvas){const a=planePresentationCanvas.clientWidth/planePresentationCanvas.clientHeight; popupCamera.aspect=a; popupCamera.updateProjectionMatrix(); popupRenderer.setSize(planePresentationCanvas.clientWidth,planePresentationCanvas.clientHeight);}}
        function onKeyDown(e){ if(!gameStarted)return; keys[e.key.toLowerCase()]=true; if(e.key===' '&&plane&&plane.userData.isAlive&&plane.visible)fireGuns(); if(e.key==='Tab'){e.preventDefault(); showRanking=true; updateRankingWebSocket(); rankingDiv.style.display='block';}}
        function onKeyUp(e){ if(!gameStarted)return; keys[e.key.toLowerCase()]=false; if(e.key==='Tab'){showRanking=false; rankingDiv.style.display='none';}}
        function onTouchStart(e){
            if(!gameStarted||e.target.id==='fireButton'||e.target.closest('#planeSelectionPopup'))return;
            e.preventDefault();
            if(e.touches.length>0){
                const t=e.touches[0];
                touchStartX=t.clientX;
                touchStartY=t.clientY;
                const sH=window.innerHeight;
                // ZMIENIONE PRZYPISANIE touchPitchInput
                if(touchStartY < sH * 0.4){ // Górna część -> nurkowanie
                    touchPitchInput = 1;
                } else if(touchStartY > sH * 0.6){ // Dolna część -> wznoszenie
                    touchPitchInput = -1;
                } else {
                    touchPitchInput = 0; // Środek -> neutralnie
                }
                touchRollInput = 0;
            }
        }
        function onTouchMove(e){
            if(!gameStarted||e.target.id==='fireButton'||e.target.closest('#planeSelectionPopup'))return;
            e.preventDefault();
            if(e.touches.length>0&&touchStartX!==null&&touchStartY!==null){
                const t=e.touches[0];
                const cX=t.clientX;
                const cY=t.clientY;
                const dX=cX-touchStartX;
                touchRollInput=Math.max(-1,Math.min(1,dX/(window.innerWidth*0.2)));
                const sH=window.innerHeight;
                 // ZMIENIONE PRZYPISANIE touchPitchInput
                 if(cY < sH * 0.4){ // Górna część -> nurkowanie
                     touchPitchInput = 1;
                 } else if(cY > sH * 0.6){ // Dolna część -> wznoszenie
                     touchPitchInput = -1;
                 } else {
                     touchPitchInput = 0; // Środek -> neutralnie
                 }
            }
        }
        function onTouchEnd(e){ if(!gameStarted)return; touchPitchInput=0; touchRollInput=0; touchStartX=null; touchStartY=null;}

    </script>
</body>

</html>